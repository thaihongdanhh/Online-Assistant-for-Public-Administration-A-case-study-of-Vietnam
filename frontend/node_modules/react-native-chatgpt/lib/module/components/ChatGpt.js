import React, { useCallback, useRef, useState } from 'react';
import { ChatGptError } from '../types';
import { ChatGptProvider } from '../contexts/ChatGptContext';
import ModalWebView from './ModalWebView';
import { postMessage, postStreamedMessage } from '../api';
import usePersistAccessToken from '../hooks/usePersistAccessToken';
import { REQUEST_DEFAULT_TIMEOUT, STREAMED_REQUEST_DEFAULT_TIMEOUT } from '../constants';
export default function ChatGpt(_ref) {
  let {
    containerStyles,
    backdropStyles,
    renderCustomCloseIcon,
    requestTimeout = REQUEST_DEFAULT_TIMEOUT,
    streamedRequestTimeout = STREAMED_REQUEST_DEFAULT_TIMEOUT,
    children
  } = _ref;
  const modalRef = useRef(null);
  const callbackRef = useRef(() => null);
  const errorCallbackRef = useRef(() => null);
  const [isWaitingForJWT, setIsWaitingForJWT] = useState(false);
  const {
    isLoaded,
    setAccessToken,
    accessToken
  } = usePersistAccessToken();
  const status = (() => {
    if (!isLoaded) return 'initializing';
    if (isWaitingForJWT) return 'getting_auth_token';
    if (!accessToken && !isWaitingForJWT) return 'logged-out';
    return 'authenticated';
  })();
  const login = useCallback(() => {
    var _modalRef$current;
    modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current = modalRef.current) === null || _modalRef$current === void 0 ? void 0 : _modalRef$current.open();
  }, []);
  const flush = useCallback(() => {
    setAccessToken('');
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  function sendMessage() {
    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      const message = arguments.length <= 0 ? undefined : arguments[0];
      const options = arguments.length <= 1 ? undefined : arguments[1];
      return postMessage({
        accessToken,
        message,
        conversationId: options === null || options === void 0 ? void 0 : options.conversationId,
        messageId: options === null || options === void 0 ? void 0 : options.messageId,
        timeout: requestTimeout,
        onTokenExpired: () => setAccessToken('')
      });
    }
    const {
      message,
      options,
      onAccumulatedResponse,
      onError
    } = arguments.length <= 0 ? undefined : arguments[0];
    if (!onAccumulatedResponse) {
      throw new ChatGptError('onAccumulatedResponse is required for stream based responses.');
    }

    // Assigning success and error callbacks to the refs so that they can be called from the webview.
    callbackRef.current = onAccumulatedResponse;
    errorCallbackRef.current = onError || (() => null);
    return postStreamedMessage({
      accessToken,
      message,
      conversationId: options === null || options === void 0 ? void 0 : options.conversationId,
      messageId: options === null || options === void 0 ? void 0 : options.messageId,
      timeout: streamedRequestTimeout
    });
  }

  // Memoize sendMessage to avoid unnecessary re-renders
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const memoizedSendMessage = useCallback(sendMessage, [accessToken]);
  return /*#__PURE__*/React.createElement(ChatGptProvider, {
    status: status,
    login: login,
    flush: flush,
    sendMessage: memoizedSendMessage
  }, children, /*#__PURE__*/React.createElement(ModalWebView, {
    ref: modalRef,
    accessToken: accessToken,
    onLoginCompleted: () => setIsWaitingForJWT(true),
    onAccessTokenChange: token => {
      setIsWaitingForJWT(false);
      setAccessToken(token);
    },
    onAccumulatedResponse: result => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, result);
    },
    onStreamError: error => {
      var _errorCallbackRef$cur;
      return (_errorCallbackRef$cur = errorCallbackRef.current) === null || _errorCallbackRef$cur === void 0 ? void 0 : _errorCallbackRef$cur.call(errorCallbackRef, error);
    },
    containerStyles: containerStyles,
    backdropStyles: backdropStyles,
    renderCustomCloseIcon: renderCustomCloseIcon
  }));
}
//# sourceMappingURL=ChatGpt.js.map