"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ChatGpt;
var _react = _interopRequireWildcard(require("react"));
var _types = require("../types");
var _ChatGptContext = require("../contexts/ChatGptContext");
var _ModalWebView = _interopRequireDefault(require("./ModalWebView"));
var _api = require("../api");
var _usePersistAccessToken = _interopRequireDefault(require("../hooks/usePersistAccessToken"));
var _constants = require("../constants");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ChatGpt(_ref) {
  let {
    containerStyles,
    backdropStyles,
    renderCustomCloseIcon,
    requestTimeout = _constants.REQUEST_DEFAULT_TIMEOUT,
    streamedRequestTimeout = _constants.STREAMED_REQUEST_DEFAULT_TIMEOUT,
    children
  } = _ref;
  const modalRef = (0, _react.useRef)(null);
  const callbackRef = (0, _react.useRef)(() => null);
  const errorCallbackRef = (0, _react.useRef)(() => null);
  const [isWaitingForJWT, setIsWaitingForJWT] = (0, _react.useState)(false);
  const {
    isLoaded,
    setAccessToken,
    accessToken
  } = (0, _usePersistAccessToken.default)();
  const status = (() => {
    if (!isLoaded) return 'initializing';
    if (isWaitingForJWT) return 'getting_auth_token';
    if (!accessToken && !isWaitingForJWT) return 'logged-out';
    return 'authenticated';
  })();
  const login = (0, _react.useCallback)(() => {
    var _modalRef$current;
    modalRef === null || modalRef === void 0 ? void 0 : (_modalRef$current = modalRef.current) === null || _modalRef$current === void 0 ? void 0 : _modalRef$current.open();
  }, []);
  const flush = (0, _react.useCallback)(() => {
    setAccessToken('');
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  function sendMessage() {
    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      const message = arguments.length <= 0 ? undefined : arguments[0];
      const options = arguments.length <= 1 ? undefined : arguments[1];
      return (0, _api.postMessage)({
        accessToken,
        message,
        conversationId: options === null || options === void 0 ? void 0 : options.conversationId,
        messageId: options === null || options === void 0 ? void 0 : options.messageId,
        timeout: requestTimeout,
        onTokenExpired: () => setAccessToken('')
      });
    }
    const {
      message,
      options,
      onAccumulatedResponse,
      onError
    } = arguments.length <= 0 ? undefined : arguments[0];
    if (!onAccumulatedResponse) {
      throw new _types.ChatGptError('onAccumulatedResponse is required for stream based responses.');
    }

    // Assigning success and error callbacks to the refs so that they can be called from the webview.
    callbackRef.current = onAccumulatedResponse;
    errorCallbackRef.current = onError || (() => null);
    return (0, _api.postStreamedMessage)({
      accessToken,
      message,
      conversationId: options === null || options === void 0 ? void 0 : options.conversationId,
      messageId: options === null || options === void 0 ? void 0 : options.messageId,
      timeout: streamedRequestTimeout
    });
  }

  // Memoize sendMessage to avoid unnecessary re-renders
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const memoizedSendMessage = (0, _react.useCallback)(sendMessage, [accessToken]);
  return /*#__PURE__*/_react.default.createElement(_ChatGptContext.ChatGptProvider, {
    status: status,
    login: login,
    flush: flush,
    sendMessage: memoizedSendMessage
  }, children, /*#__PURE__*/_react.default.createElement(_ModalWebView.default, {
    ref: modalRef,
    accessToken: accessToken,
    onLoginCompleted: () => setIsWaitingForJWT(true),
    onAccessTokenChange: token => {
      setIsWaitingForJWT(false);
      setAccessToken(token);
    },
    onAccumulatedResponse: result => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, result);
    },
    onStreamError: error => {
      var _errorCallbackRef$cur;
      return (_errorCallbackRef$cur = errorCallbackRef.current) === null || _errorCallbackRef$cur === void 0 ? void 0 : _errorCallbackRef$cur.call(errorCallbackRef, error);
    },
    containerStyles: containerStyles,
    backdropStyles: backdropStyles,
    renderCustomCloseIcon: renderCustomCloseIcon
  }));
}
//# sourceMappingURL=ChatGpt.js.map